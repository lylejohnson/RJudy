/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.16u-20021018-1710
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/* ruby.swg */
/* Implementation : RUBY */
#define SWIGRUBY 1

#include "ruby.h"

#define NUM2USHRT(n) NUM2UINT(n)
#define NUM2SHRT(n) (\
    (SHRT_MIN <= NUM2INT(n) && NUM2INT(n) <= SHRT_MAX)\
    ? (short)NUM2INT(n)\
    : (rb_raise(rb_eArgError, "integer %d out of range of `short'",\
               NUM2INT(n)), (short)0)\
)

/* Ruby 1.7 defines NUM2LL(), LL2NUM() and ULL2NUM() macros */
#ifndef NUM2LL
#define NUM2LL(x) NUM2LONG((x))
#endif
#ifndef LL2NUM
#define LL2NUM(x) INT2NUM((long) (x))
#endif
#ifndef ULL2NUM
#define ULL2NUM(x) UINT2NUM((unsigned long) (x))
#endif

/* Ruby 1.7 doesn't (yet) define NUM2ULL() */
#ifndef NUM2ULL
#if HAVE_LONG_LONG
#define NUM2ULL(x) rb_num2ull((x))
#else
#define NUM2ULL(x) NUM2ULONG(x)
#endif
#endif

/*
 * Need to be very careful about how these macros are defined, especially
 * when compiling C++ code or C code with an ANSI C compiler.
 *
 * VALUEFUNC(f) is a macro used to typecast a C function that implements
 * a Ruby method so that it can be passed as an argument to API functions
 * like rb_define_method() and rb_define_singleton_method().
 *
 * VOIDFUNC(f) is a macro used to typecast a C function that implements
 * either the "mark" or "free" stuff for a Ruby Data object, so that it
 * can be passed as an argument to API functions like Data_Wrap_Struct()
 * and Data_Make_Struct().
 */
 
#ifdef __cplusplus
#  ifndef RUBY_METHOD_FUNC /* These definitions should work for Ruby 1.4.6 */
#    define VALUEFUNC(f) ((VALUE (*)()) f)
#    define VOIDFUNC(f)  ((void (*)()) f)
#  else
#    ifndef ANYARGS /* These definitions should work for Ruby 1.6 */
#      define VALUEFUNC(f) ((VALUE (*)()) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    else /* These definitions should work for Ruby 1.7 */
#      define VALUEFUNC(f) ((VALUE (*)(ANYARGS)) f)
#      define VOIDFUNC(f)  ((RUBY_DATA_FUNC) f)
#    endif
#  endif
#else
#  define VALUEFUNC(f) (f)
#  define VOIDFUNC(f) (f)
#endif

typedef struct {
  VALUE  klass;
  void  (*mark)(void *);
  void  (*destroy)(void *);
} swig_class;

/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) extern a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#                       define SWIGIMPORT(a) extern a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#                       define SWIGIMPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#                       define SWIGIMPORT(a) a
#               endif
#       endif
#else
#       define SWIGEXPORT(a) a
#       define SWIGIMPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct swig_type_info {
  const char             *name;                 
  swig_converter_func     converter;
  const char             *str;
  void                   *clientdata;	
  swig_dycast_func        dcast;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE

SWIGIMPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGIMPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGIMPORT(void *)           SWIG_TypeCast(swig_type_info *, void *);
SWIGIMPORT(swig_type_info *) SWIG_TypeDynamicCast(swig_type_info *, void **);
SWIGIMPORT(swig_type_info *) SWIG_TypeQuery(const char *);
SWIGIMPORT(void)             SWIG_TypeClientData(swig_type_info *, void *);

#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      if (tc->clientdata) ti->clientdata = tc->clientdata;	
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  do {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  } while (s && (s != ty->next));
  return 0;
}

/* Cast a pointer up an inheritance hierarchy */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

/* Set the clientdata field for a type */
SWIGRUNTIME(void)
SWIG_TypeClientData(swig_type_info *ti, void *clientdata) {
  swig_type_info *tc, *equiv;
  if (ti->clientdata) return;
  ti->clientdata = clientdata;
  equiv = ti->next;
  while (equiv) {
    if (!equiv->converter) {
      tc = swig_type_list;
      while (tc) {
	if ((strcmp(tc->name, equiv->name) == 0))
	  SWIG_TypeClientData(tc,clientdata);
	tc = tc->prev;
      }
    }
    equiv = equiv->next;
  }
}
#endif

#ifdef __cplusplus
}

#endif

/* rubydef.swg */
#ifdef __cplusplus
extern "C" {
#endif

static VALUE _mSWIG = Qnil;
static VALUE _cSWIG_Pointer = Qnil;

/* Initialize Ruby runtime support */
SWIGRUNTIME(void)
SWIG_InitRuntime(void)
{
    if (_mSWIG == Qnil) {
        _mSWIG = rb_define_module("SWIG");
    }
}

/* Define Ruby class for C type */
SWIGRUNTIME(void)
SWIG_define_class(swig_type_info *type)
{
    VALUE klass;
    char *klass_name = (char *) malloc(4 + strlen(type->name) + 1);
    sprintf(klass_name, "TYPE%s", type->name);
    if (NIL_P(_cSWIG_Pointer)) {
	_cSWIG_Pointer = rb_define_class_under(_mSWIG, "Pointer", rb_cObject);
	rb_undef_method(CLASS_OF(_cSWIG_Pointer), "new");
    }
    klass = rb_define_class_under(_mSWIG, klass_name, _cSWIG_Pointer);
    free((void *) klass_name);
}

/* Create a new pointer object */
SWIGRUNTIME(VALUE)
SWIG_NewPointerObj(void *ptr, swig_type_info *type, int own)
{
    char *klass_name;
    swig_class *sklass;
    VALUE klass;
    VALUE obj;
    
    if (!ptr)
	return Qnil;
    
    if (type->clientdata) {
      sklass = (swig_class *) type->clientdata;
      obj = Data_Wrap_Struct(sklass->klass, VOIDFUNC(sklass->mark), (own ? VOIDFUNC(sklass->destroy) : 0), ptr);
    } else {
      klass_name = (char *) malloc(4 + strlen(type->name) + 1);
      sprintf(klass_name, "TYPE%s", type->name);
      klass = rb_const_get(_mSWIG, rb_intern(klass_name));
      free((void *) klass_name);
      obj = Data_Wrap_Struct(klass, 0, 0, ptr);
    }
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Create a new class instance (always owned) */
SWIGRUNTIME(VALUE)
SWIG_NewClassInstance(VALUE klass, swig_type_info *type)
{
    VALUE obj;
    swig_class *sklass = (swig_class *) type->clientdata;
    obj = Data_Wrap_Struct(klass, VOIDFUNC(sklass->mark), VOIDFUNC(sklass->destroy), 0);
    rb_iv_set(obj, "__swigtype__", rb_str_new2(type->name));
    return obj;
}

/* Get type mangle from class name */
SWIGRUNTIME(char *)
SWIG_MangleStr(VALUE obj)
{
  VALUE stype = rb_iv_get(obj, "__swigtype__");
  return STR2CSTR(stype);
}

/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(VALUE obj, void **ptr, swig_type_info *ty, int flags)
{
  char *c;
  swig_type_info *tc;

  /* Grab the pointer */
  if (NIL_P(obj)) {
    *ptr = 0;
    return 0;
  } else
    Data_Get_Struct(obj, void, *ptr);
  
  /* Do type-checking if type info was provided */
  if (ty) {
    if (ty->clientdata) {
        if (!rb_obj_is_kind_of(obj, ((swig_class *) (ty->clientdata))->klass)) {
          if (flags)
	    rb_raise(rb_eTypeError, "wrong argument type (expected %s)", ty->str);
	  else
	    return -1;
	}
        if (*ptr == 0)
	  rb_raise(rb_eRuntimeError, "This %s already released", ty->str);
    } else {
      if ((c = SWIG_MangleStr(obj)) == NULL) {
        if (flags)
	  rb_raise(rb_eTypeError, "Expected %s", ty->str);
	else
	  return -1;
      }
      tc = SWIG_TypeCheck(c, ty);
      if (!tc) {
        if (flags)
	  rb_raise(rb_eTypeError, "Expected %s", ty->str);
	else
	  return -1;
      }
      *ptr = SWIG_TypeCast(tc, *ptr);
    }
  }
  return 0;
}

/* Check convert */
SWIGRUNTIME(int)
SWIG_CheckConvert(VALUE obj, swig_type_info *ty)
{
  char *c = SWIG_MangleStr(obj);
  if (!c)
    return 0;
  return SWIG_TypeCheck(c,ty) != 0;
}

/* Pack binary data into a string */
SWIGRUNTIME(char *)
SWIG_PackData(char *c, void *ptr, int sz) {
  static char hex[17] = "0123456789abcdef";
  int i;
  unsigned char *u = (unsigned char *) ptr;
  register unsigned char uu;
  for (i = 0; i < sz; i++,u++) {
    uu = *u;
    *(c++) = hex[(uu & 0xf0) >> 4];
    *(c++) = hex[uu & 0xf];
  }
  return c;
}

/* Unpack binary data from a string */
SWIGRUNTIME(char *)
SWIG_UnpackData(char *c, void *ptr, int sz) {
  register unsigned char uu = 0;
  register int d;
  unsigned char *u = (unsigned char *) ptr;
  int i;
  for (i = 0; i < sz; i++, u++) {
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu = ((d - '0') << 4);
    else if ((d >= 'a') && (d <= 'f'))
      uu = ((d - ('a'-10)) << 4);
    d = *(c++);
    if ((d >= '0') && (d <= '9'))
      uu |= (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      uu |= (d - ('a'-10));
    *u = uu;
  }
  return c;
}

SWIGRUNTIME(VALUE)
SWIG_NewPackedObj(void *ptr, int sz, swig_type_info *type) {
  char result[1024];
  char *r = result;
  if ((2*sz + 1 + strlen(type->name)) > 1000) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r, ptr, sz);
  strcpy(r, type->name);
  return rb_str_new2(result);
}

/* Convert a packed value value */
SWIGRUNTIME(void)
SWIG_ConvertPacked(VALUE obj, void *ptr, int sz, swig_type_info *ty, int flags) {
  swig_type_info *tc;
  char  *c;

  if (TYPE(obj) != T_STRING) goto type_error;
  c = STR2CSTR(obj);
  /* Pointer values must start with leading underscore */
  if (*c != '_') goto type_error;
  c++;
  c = SWIG_UnpackData(c, ptr, sz);
  if (ty) {
    tc = SWIG_TypeCheck(c, ty);
    if (!tc) goto type_error;
  }
  return;

type_error:

  if (flags) {
    if (ty) {
      rb_raise(rb_eTypeError, "Type error. Expected %s", ty->name);
    } else {
      rb_raise(rb_eTypeError, "Expected a pointer");
    }
  }
}

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_JudySL swig_types[0] 
#define  SWIGTYPE_p_JudyL swig_types[1] 
#define  SWIGTYPE_p_Judy1 swig_types[2] 
#define  SWIGTYPE_p_JudyHash swig_types[3] 
static swig_type_info *swig_types[5];

/* -------- TYPES TABLE (END) -------- */

#define SWIG_init    Init_judy
#define SWIG_name    "Judy"

static VALUE mJudy;

#include <assert.h>
#include <math.h>

#include "Judy.h"

#ifdef MAXLINELEN
#undef MAXLINELEN
#endif
#define MAXLINELEN 65536


typedef struct Judy1 {
    Pvoid_t PJ1Array;
} Judy1;

#ifndef bool
#define bool int
#endif

struct Judy1 *new_Judy1(){
      Judy1 *pJudy1 = ALLOC(Judy1);
      pJudy1->PJ1Array = NULL;
      return pJudy1;
    }
bool Judy1_set(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1S(Rc_int, self->PJ1Array, Index);
      return Rc_int;
    }
bool Judy1_unset(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1U(Rc_int, self->PJ1Array, Index);
      return Rc_int;
    }
bool Judy1_test(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1T(Rc_int, self->PJ1Array, Index);
      return Rc_int;
    }
VALUE Judy1_count__SWIG_0(struct Judy1 *self,Word_t Index1,Word_t Index2){
      Word_t Rc_word;
      JError_t JError;
      Rc_word = Judy1Count(self->PJ1Array, Index1, Index2, &JError);
      if (Rc_word == 0) {
        if (JU_ERRNO(&JError) == JU_ERRNO_NONE)
	  return INT2FIX(0);
	if (JU_ERRNO(&JError) == JU_ERRNO_FULL)
	  return UINT2NUM(pow(2, 8*sizeof(Word_t)));
      }
      return UINT2NUM(Rc_word);
    }
VALUE Judy1_count__SWIG_1(struct Judy1 *self){
      Word_t Rc_word;
      JError_t JError;
      Rc_word = Judy1Count(self->PJ1Array, 0, -1, &JError);
      if (Rc_word == 0) {
        if (JU_ERRNO(&JError) == JU_ERRNO_NONE)
	  return INT2FIX(0);
	if (JU_ERRNO(&JError) == JU_ERRNO_FULL)
	  return UINT2NUM(pow(2, 8*sizeof(Word_t)));
      }
      return UINT2NUM(Rc_word);
    }
VALUE Judy1_by_count(struct Judy1 *self,Word_t Nth){
      Word_t Index;
      int Rc_int;
      J1BC(Rc_int, self->PJ1Array, Nth, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
Word_t Judy1_free_array(struct Judy1 *self){
      Word_t Rc_word;
      J1FA(Rc_word, self->PJ1Array);
      return Rc_word;
    }
Word_t Judy1_mem_used(struct Judy1 *self){
      Word_t Rc_word;
      J1MU(Rc_word, self->PJ1Array);
      return Rc_word;
    }
VALUE Judy1_first_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1F(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE Judy1_next_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1N(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE Judy1_last_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1L(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE Judy1_prev_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1P(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE Judy1_first_empty_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1FE(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE Judy1_next_empty_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1NE(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE Judy1_last_empty_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1LE(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE Judy1_prev_empty_index(struct Judy1 *self,Word_t Index){
      int Rc_int;
      J1PE(Rc_int, self->PJ1Array, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
Judy1 *Judy1_each_index(struct Judy1 *self){
      int Rc_int;
      Word_t Index = 0;
      J1F(Rc_int, self->PJ1Array, Index);
      while (Rc_int != 0) {
	rb_yield(UINT2NUM(Index));
        J1N(Rc_int, self->PJ1Array, Index);
      }
      return self;
    }
Judy1 *Judy1_each_empty_index(struct Judy1 *self){
      int Rc_int;
      Word_t Index = 0;
      J1FE(Rc_int, self->PJ1Array, Index);
      while (Rc_int != 0) {
	rb_yield(UINT2NUM(Index));
        J1NE(Rc_int, self->PJ1Array, Index);
      }
      return self;
    }
bool Judy1_full(struct Judy1 const *self){
      JError_t JError;
      return ((0 == Judy1Count(self->PJ1Array, 0, -1, &JError)) &&
		      (JU_ERRNO(&JError) == JU_ERRNO_FULL));
    }
VALUE Judy1_to_a(struct Judy1 *self){
      Word_t Index;
      Word_t lastIndex;
      int Rc_int;
      VALUE ary;
      ary = rb_ary_new();
      lastIndex = -1;
      J1L(Rc_int, self->PJ1Array, lastIndex);
      if (Rc_int == 1) {
        for (Index = 0; Index <= lastIndex; Index++) {
	  J1T(Rc_int, self->PJ1Array, Index);
	  rb_ary_push(ary, INT2NUM(Rc_int));
	}
      }
      return ary;
    }
VALUE Judy1_to_s(struct Judy1 *self){
      Word_t Index;
      Word_t lastIndex;
      int Rc_int;
      VALUE ary;
      ary = rb_ary_new();
      lastIndex = -1;
      J1L(Rc_int, self->PJ1Array, lastIndex);
      if (Rc_int == 1) {
        for (Index = 0; Index <= lastIndex; Index++) {
	  J1T(Rc_int, self->PJ1Array, Index);
	  rb_ary_push(ary, INT2NUM(Rc_int));
	}
      }
      return rb_funcall(rb_funcall(ary, rb_intern("reverse"), 0), rb_intern("to_s"), 0);
    }
void delete_Judy1(struct Judy1 *self){
      Word_t Rc_word;
      J1FA(Rc_word, self->PJ1Array);
      xfree((void *) self);
    }

swig_class cJudy1;
static void free_Judy1(struct Judy1 *);

typedef struct JudyL {
    Pvoid_t PJLArray;
} JudyL;

void JudyL_markfunc(void *ptr) {
    Word_t *PValue;
    Word_t Index = 0;
    JLF(PValue, ((JudyL *) ptr)->PJLArray, Index);
    while (PValue) {
    	rb_gc_mark((VALUE) *PValue);
        JLN(PValue, ((JudyL *) ptr)->PJLArray, Index);
    }
}

struct JudyL *new_JudyL(){
      JudyL *pJudyL = ALLOC(JudyL);
      pJudyL->PJLArray = NULL;
      return pJudyL;
    }
VALUE JudyL___setitem__(struct JudyL *self,Word_t index,VALUE value){
      Word_t *PValue;
      JLI(PValue, self->PJLArray, index);
      *PValue = (Word_t) value;
      return value;
    }
VALUE JudyL_delete_at(struct JudyL *self,Word_t Index){
      Word_t *PValue;
      int Rc_int;
      VALUE v = Qnil;
      JLG(PValue, self->PJLArray, Index);
      if (PValue) {
        v = (VALUE) *PValue;
        JLD(Rc_int, self->PJLArray, Index);
      }
      return v;
    }
VALUE JudyL___getitem__(struct JudyL *self,Word_t Index){
      Word_t *PValue;
      JLG(PValue, self->PJLArray, Index);
      return PValue ? (VALUE) *PValue : Qnil;
    }
VALUE JudyL_count__SWIG_0(struct JudyL const *self,Word_t Index1,Word_t Index2){
      Word_t Rc_word;
      JError_t JError;
      Rc_word = JudyLCount(self->PJLArray, Index1, Index2, &JError);
      if (Rc_word == 0) {
        if (JU_ERRNO(&JError) == JU_ERRNO_NONE)
	  return INT2FIX(0);
	if (JU_ERRNO(&JError) == JU_ERRNO_FULL)
	  return UINT2NUM(pow(2, 8*sizeof(Word_t)));
      }
      return UINT2NUM(Rc_word);
    }
VALUE JudyL_count__SWIG_1(struct JudyL const *self){
      Word_t Rc_word;
      JError_t JError;
      Rc_word = JudyLCount(self->PJLArray, 0, -1, &JError);
      if (Rc_word == 0) {
        if (JU_ERRNO(&JError) == JU_ERRNO_NONE)
	  return INT2FIX(0);
	if (JU_ERRNO(&JError) == JU_ERRNO_FULL)
	  return UINT2NUM(pow(2, 8*sizeof(Word_t)));
      }
      return UINT2NUM(Rc_word);
    }
VALUE JudyL_by_count(struct JudyL const *self,Word_t Nth){
      Word_t Index;
      Word_t *PValue;
      JLBC(PValue, self->PJLArray, Nth, Index);
      return PValue ? UINT2NUM(Index) : Qnil;
    }
Word_t JudyL_free_array(struct JudyL *self){
      Word_t Rc_word ;
      JLFA(Rc_word, self->PJLArray);
      return Rc_word;
    }
Word_t JudyL_mem_used(struct JudyL const *self){
      Word_t Rc_word;
      JLMU(Rc_word, self->PJLArray);
      return Rc_word;
    }
VALUE JudyL_first_index(struct JudyL const *self,Word_t Index){
      Word_t *PValue;
      JLF(PValue, self->PJLArray, Index);
      return PValue ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_next_index(struct JudyL const *self,Word_t Index){
      Word_t *PValue;
      JLN(PValue, self->PJLArray, Index);
      return PValue ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_last_index(struct JudyL const *self,Word_t Index){
      Word_t *PValue;
      JLL(PValue, self->PJLArray, Index);
      return PValue ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_prev_index(struct JudyL const *self,Word_t Index){
      Word_t *PValue;
      JLP(PValue, self->PJLArray, Index);
      return PValue ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_first_empty_index(struct JudyL const *self,Word_t Index){
      int Rc_int;
      JLFE(Rc_int, self->PJLArray, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_next_empty_index(struct JudyL const *self,Word_t Index){
      int Rc_int;
      JLNE(Rc_int, self->PJLArray, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_last_empty_index(struct JudyL const *self,Word_t Index){
      int Rc_int;
      JLLE(Rc_int, self->PJLArray, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_prev_empty_index(struct JudyL const *self,Word_t Index){
      int Rc_int;
      JLPE(Rc_int, self->PJLArray, Index);
      return (Rc_int == 1) ? UINT2NUM(Index) : Qnil;
    }
VALUE JudyL_first(struct JudyL const *self){
      Word_t *PValue;
      Word_t Index = 0;
      JLF(PValue, self->PJLArray, Index);
      return PValue ? (VALUE) (*PValue) : Qnil;
    }
VALUE JudyL_last(struct JudyL const *self){
      Word_t *PValue;
      Word_t Index = -1;
      JLL(PValue, self->PJLArray, Index);
      return PValue ? (VALUE) (*PValue) : Qnil;
    }
JudyL *JudyL_each(struct JudyL *self){
      Word_t *PValue;
      VALUE value;
      Word_t Index = 0;
      JLF(PValue, self->PJLArray, Index);
      while (PValue) {
        value = (VALUE) *PValue;
	rb_yield(value);
        JLN(PValue, self->PJLArray, Index);
      }
      return self;
    }
JudyL *JudyL_each_index(struct JudyL *self){
      Word_t *PValue;
      Word_t Index = 0;
      JLF(PValue, self->PJLArray, Index);
      while (PValue) {
	rb_yield(UINT2NUM(Index));
        JLN(PValue, self->PJLArray, Index);
      }
      return self;
    }
JudyL *JudyL_each_empty_index(struct JudyL *self){
      int Rc_int;
      Word_t Index = 0;
      JLFE(Rc_int, self->PJLArray, Index);
      while (Rc_int != 0) {
	rb_yield(UINT2NUM(Index));
        JLNE(Rc_int, self->PJLArray, Index);
      }
      return self;
    }
JudyL *JudyL_clear(struct JudyL *self){
      Word_t Rc_word;
      JLFA(Rc_word, self->PJLArray);
      return self;
    }
int JudyL_empty(struct JudyL const *self){
      return (self->PJLArray == NULL) ? 1 : 0;
    }
int JudyL_include(struct JudyL const *self,VALUE o){
      Word_t *PValue;
      VALUE value;
      Word_t Index = 0;
      JLF(PValue, self->PJLArray, Index);
      while (PValue) {
        value = (VALUE) *PValue;
	if (rb_equal(value, o) == Qtrue)
	  return 1;
	JLN(PValue, self->PJLArray, Index);
      }
      return 0;
    }
bool JudyL_full(struct JudyL const *self){
      JError_t JError;
      return ((0 == JudyLCount(self->PJLArray, 0, -1, &JError)) &&
		      (JU_ERRNO(&JError) == JU_ERRNO_FULL));
    }
VALUE JudyL_to_a(struct JudyL *self){
      Word_t *PValue;
      VALUE ary;
      Word_t Index;
      Word_t lastIndex = -1;
      ary = rb_ary_new();
      JLL(PValue, self->PJLArray, lastIndex);
      if (PValue) {
        for (Index = 0; Index <= lastIndex; Index++) {
          JLG(PValue, self->PJLArray, Index);
	  rb_ary_push(ary, PValue ? (VALUE) *PValue : Qnil);
	}
      }
      return ary;
    }
VALUE JudyL_to_s(struct JudyL *self){
      Word_t *PValue;
      VALUE ary;
      Word_t Index;
      Word_t lastIndex = -1;
      ary = rb_ary_new();
      JLL(PValue, self->PJLArray, lastIndex);
      if (PValue) {
        for (Index = 0; Index <= lastIndex; Index++) {
          JLG(PValue, self->PJLArray, Index);
	  rb_ary_push(ary, PValue ? (VALUE) *PValue : Qnil);
	}
      }
      return rb_funcall(ary, rb_intern("to_s"), 0);
    }
void delete_JudyL(struct JudyL *self){
      Word_t Rc_word;
      JLFA(Rc_word, self->PJLArray);
      xfree((void *) self);
    }

swig_class cJudyL;
static void free_JudyL(struct JudyL *);

typedef struct JudySL {
    Pvoid_t PJSLArray;
} JudySL;

void JudySL_markfunc(void *ptr) {
    Word_t *PValue;
    char Index[MAXLINELEN];
    strcpy(Index, "");
    JSLF(PValue, ((JudySL*) ptr)->PJSLArray, Index);
    while (PValue) {
    	rb_gc_mark((VALUE) *PValue);
	JSLN(PValue, ((JudySL*) ptr)->PJSLArray, Index);
    }
}

static void JudySL_foreach(const JudySL *self, void (*func)(const char *, VALUE, void *), void *arg) {
  Word_t *PValue;
  char Index[MAXLINELEN];
  strcpy(Index, "");
  JSLF(PValue, self->PJSLArray, Index);
  while (PValue) {
    func(Index, (VALUE) *PValue, arg);
    JSLN(PValue, self->PJSLArray, Index);
  }
}

static void JudySL_keysCB(const char *key, VALUE value, void *arg) {
  rb_ary_push((VALUE) arg, rb_str_new2(key));
}

static void JudySL_valuesCB(const char *key, VALUE value, void *arg) {
  rb_ary_push((VALUE) arg, value);
}

static void JudySL_eachCB(const char *key, VALUE value, void *arg) {
  VALUE ary = rb_ary_new();
  rb_ary_push(ary, rb_str_new2(key));
  rb_ary_push(ary, value);
  rb_yield(ary);
}

static void JudySL_each_keyCB(const char *key, VALUE value, void *arg) {
  rb_yield(rb_str_new2(key));
}

static void JudySL_each_valueCB(const char *key, VALUE value, void *arg) {
  rb_yield(value);
}

static void JudySL_lengthCB(const char *key, VALUE value, void *arg) {
  (*((Word_t *) arg))++;
}

static void JudySL_to_aCB(const char *key, VALUE value, void *arg) {
  VALUE ary = rb_ary_new();
  rb_ary_push(ary, rb_str_new2(key));
  rb_ary_push(ary, value);
  rb_ary_push((VALUE) arg, ary);
}

struct JudySL *new_JudySL(){
      JudySL *pJudySL = ALLOC(JudySL);
      pJudySL->PJSLArray = NULL;
      return pJudySL;
    }
VALUE JudySL___setitem__(struct JudySL *self,char const *key,VALUE value){
      Word_t *PValue;
      assert(key);
      JSLI(PValue, self->PJSLArray, key);
      assert(PValue);
      *PValue = (Word_t) value;
      return value;
    }
VALUE JudySL_delete(struct JudySL *self,char const *key){
      Word_t *PValue;
      int Rc_int;
      VALUE value;
      assert(key);
      JSLG(PValue, self->PJSLArray, key);
      value = PValue ? (VALUE) *PValue : Qnil;
      JSLD(Rc_int, self->PJSLArray, key);
      return value;
    }
VALUE JudySL___getitem__(struct JudySL const *self,char const *key){
      Word_t *PValue;
      assert(key);
      JSLG(PValue, self->PJSLArray, key);
      return PValue ? (VALUE) *PValue : Qnil;
    }
Word_t JudySL_free_array(struct JudySL *self){
      Word_t Rc_word;
      JSLFA(Rc_word, self->PJSLArray);
      return Rc_word;
    }
char *JudySL_first_key(struct JudySL const *self,char const *startIndex){
      Word_t *PValue;
      static char Index[MAXLINELEN];
      assert(startIndex);
      strncpy(Index, startIndex, MAXLINELEN-1);
      Index[MAXLINELEN-1] = '\0';
      JSLF(PValue, self->PJSLArray, Index);
      return PValue ? Index : NULL;
    }
char *JudySL_next_key(struct JudySL const *self,char const *startIndex){
      Word_t *PValue;
      static char Index[MAXLINELEN];
      assert(startIndex);
      strncpy(Index, startIndex, MAXLINELEN-1);
      Index[MAXLINELEN-1] = '\0';
      JSLN(PValue, self->PJSLArray, Index);
      return PValue ? Index : NULL;
    }
char *JudySL_last_key__SWIG_0(struct JudySL const *self,char const *startIndex){
      Word_t *PValue;
      static char Index[MAXLINELEN];
      assert(startIndex);
      strncpy(Index, startIndex, MAXLINELEN-1);
      Index[MAXLINELEN-1] = '\0';
      JSLL(PValue, self->PJSLArray, Index);
      return PValue ? Index : NULL;
    }
char *JudySL_last_key__SWIG_1(struct JudySL const *self){
      Word_t *PValue;
      static char Index[MAXLINELEN];
      memset(Index, 0xff, MAXLINELEN-1);
      Index[MAXLINELEN-1] = '\0';
      JSLL(PValue, self->PJSLArray, Index);
      return PValue ? Index : NULL;
    }
char *JudySL_prev_key(struct JudySL const *self,char const *startIndex){
      Word_t *PValue;
      static char Index[MAXLINELEN];
      assert(startIndex);
      strncpy(Index, startIndex, MAXLINELEN-1);
      Index[MAXLINELEN-1] = '\0';
      JSLP(PValue, self->PJSLArray, Index);
      return PValue ? Index : NULL;
    }
int JudySL_has_key(struct JudySL *self,char const *key){
      Word_t *PValue;
      JSLG(PValue, self->PJSLArray, key);
      return (PValue != NULL);
    }
JudySL *JudySL_each(struct JudySL *self){
      JudySL_foreach(self, JudySL_eachCB, NULL);
      return self;
    }
JudySL *JudySL_each_key(struct JudySL *self){
      JudySL_foreach(self, JudySL_each_keyCB, NULL);
      return self;
    }
JudySL *JudySL_each_value(struct JudySL *self){
      JudySL_foreach(self, JudySL_each_valueCB, NULL);
      return self;
    }
JudySL *JudySL_clear(struct JudySL *self){
      Word_t Rc_word;
      JSLFA(Rc_word, self->PJSLArray);
      return self;
    }
int JudySL_empty(struct JudySL *self){
      return (self->PJSLArray == NULL) ? 1 : 0;
    }
VALUE JudySL_keys(struct JudySL *self){
      VALUE ary = rb_ary_new();
      JudySL_foreach(self, JudySL_keysCB, (void *) ary);
      return ary;
    }
VALUE JudySL_values(struct JudySL *self){
      VALUE ary = rb_ary_new();
      JudySL_foreach(self, JudySL_valuesCB, (void *) ary);
      return ary;
    }
Word_t JudySL_length(struct JudySL const *self){
      Word_t sz = 0;
      JudySL_foreach(self, JudySL_lengthCB, (void *) &sz);
      return sz;
    }
VALUE JudySL_to_a(struct JudySL *self){
      VALUE ary = rb_ary_new();
      JudySL_foreach(self, JudySL_to_aCB, (void *) ary);
      return ary;
    }
VALUE JudySL_to_s(struct JudySL *self){
      VALUE ary = rb_ary_new();
      JudySL_foreach(self, JudySL_to_aCB, (void *) ary);
      return rb_funcall(ary, rb_intern("join"), 0);
    }
void delete_JudySL(struct JudySL *self){
      Word_t Rc_word;
      JSLFA(Rc_word, self->PJSLArray);
      xfree((void *) self);
    }

swig_class cJudySL;
static void free_JudySL(struct JudySL *);

#include "JudyHash.h"

static void JudyHash_eachCB(VALUE key, VALUE value, void *arg) {
  VALUE ary = rb_ary_new();
  rb_ary_push(ary, key);
  rb_ary_push(ary, value);
  rb_yield(ary);
}

static void JudyHash_each_keyCB(VALUE key, VALUE value, void *arg) {
  rb_yield(key);
}

static void JudyHash_each_valueCB(VALUE key, VALUE value, void *arg) {
  rb_yield(value);
}

static void JudyHash_keysCB(VALUE key, VALUE value, void *arg) {
  rb_ary_push((VALUE) arg, key);
}

static void JudyHash_valuesCB(VALUE key, VALUE value, void *arg) {
  rb_ary_push((VALUE) arg, value);
}

static void JudyHash_lengthCB(VALUE key, VALUE value, void *arg) {
  (*((Word_t *) arg))++;
}

static void JudyHash_to_aCB(VALUE key, VALUE value, void *arg) {
  VALUE ary;
  ary = rb_ary_new();
  rb_ary_push(ary, key);
  rb_ary_push(ary, value);
  rb_ary_push((VALUE) arg, ary);
}

struct JudyHash *new_JudyHash(){
      int i;
      JudyHash *pJudyHash = ALLOC(JudyHash);
      for (i = 0; i < HASHSIZE; i++) {
        pJudyHash->PJLArray[i] = NULL;
      }
      pJudyHash->ifnone = Qnil;
      return pJudyHash;
    }
VALUE JudyHash___setitem__(struct JudyHash *self,VALUE key,VALUE value){
      Word_t *PValue;
      JudyHashNode *pNode, *pPrev;
      unsigned int h = HASHCODE(key);
      JLI(PValue, HASHARRAY(h), HASHINDEX(h));
      assert(PValue);
      if (*PValue) {
        for (pNode = HASHNODE(PValue); pNode; pPrev = pNode, pNode = pNode->next) {
	  if (EQUAL(pNode->key, key)) {
	    pNode->value = value;
	    return value;
	  }
	}
	pPrev->next = NewJudyHashNode();
	pPrev->next->key = (TYPE(key) == T_STRING) ? rb_str_new4(key) : key;
	pPrev->next->value = value;
	return value;
      } else {
        NEWNODE(PValue);
        HASHNODE(PValue)->key = (TYPE(key) == T_STRING) ? rb_str_new4(key) : key;
        HASHNODE(PValue)->value = value;
        return value;
      }
    }
VALUE JudyHash_delete(struct JudyHash *self,VALUE key){
      int Rc_int;
      Word_t *PValue;
      VALUE value;
      JudyHashNode *pNode, *pPrev;
      unsigned int h = HASHCODE(key);
      value = self->ifnone;
      JLG(PValue, HASHARRAY(h), HASHINDEX(h));
      if (PValue) {
        for (pPrev = NULL, pNode = HASHNODE(PValue); pNode; pPrev = pNode, pNode = pNode->next) {
	  if (EQUAL(pNode->key, key)) {
            value = pNode->value;
	    if (pPrev)
	      pPrev->next = pNode->next;
	    if (HASHNODE(PValue) == pNode)
	      HASHNODE(PValue) = pPrev;
	    xfree((void *) pNode);
	    if (!HASHNODE(PValue))
	      JLD(Rc_int, HASHARRAY(h), HASHINDEX(h));
	    break;
	  }
	}
      }
      return value;
    }
VALUE JudyHash___getitem__(struct JudyHash const *self,VALUE key){
      Word_t *PValue;
      JudyHashNode *pNode;
      unsigned int h = HASHCODE(key);
      JLG(PValue, HASHARRAY(h), HASHINDEX(h));
      if (PValue) {
        for (pNode = HASHNODE(PValue); pNode; pNode = pNode->next) {
	  if (EQUAL(pNode->key, key))
	    return pNode->value;
	}
      }
      return self->ifnone;
    }
Word_t JudyHash_free_array(struct JudyHash *self){
      Word_t *PValue;
      Word_t Index, Rc_word;
      JudyHashNode *pNode, *pTmp;
      int i;
      Word_t total = 0;
      for (i = 0; i < HASHSIZE; i++) {
        Index = 0;
        JLF(PValue, self->PJLArray[i], Index);
	while (PValue) {
	  pNode = HASHNODE(PValue);
	  while (pNode) {
	    pTmp = pNode;
	    pNode = pNode->next;
	    xfree((void *) pTmp);
	    total += sizeof(JudyHashNode);
	  }
	  JLN(PValue, self->PJLArray[i], Index);
	}
	JLFA(Rc_word, self->PJLArray[i]);
      	total += Rc_word;
      }
      return total;
    }
int JudyHash_has_key(struct JudyHash *self,VALUE key){
      Word_t *PValue;
      JudyHashNode *pNode;
      unsigned int h = HASHCODE(key);
      JLG(PValue, HASHARRAY(h), HASHINDEX(h));
      if (PValue) {
	for (pNode = HASHNODE(PValue); pNode; pNode = pNode->next) {
	  if (EQUAL(pNode->key, key))
	    return 1;
	}
      }
      return 0;
    }
JudyHash *JudyHash_each(struct JudyHash *self){
      JudyHash_foreach(self, JudyHash_eachCB, NULL);
      return self;
    }
JudyHash *JudyHash_each_key(struct JudyHash *self){
      JudyHash_foreach(self, JudyHash_each_keyCB, NULL);
      return self;
    }
JudyHash *JudyHash_each_value(struct JudyHash *self){
      JudyHash_foreach(self, JudyHash_each_valueCB, NULL);
      return self;
    }
JudyHash *JudyHash_clear(struct JudyHash *self){
      Word_t *PValue;
      Word_t Index, Rc_word;
      JudyHashNode *pNode, *pTmp;
      int i;
      for (i = 0; i < HASHSIZE; i++) {
        Index = 0;
        JLF(PValue, self->PJLArray[i], Index);
	while (PValue) {
	  pNode = HASHNODE(PValue);
	  while (pNode) {
	    pTmp = pNode;
	    pNode = pNode->next;
	    xfree((void *) pTmp);
	  }
	  JLN(PValue, self->PJLArray[i], Index);
	}
      	JLFA(Rc_word, self->PJLArray[i]);
      }
      return self;
    }
int JudyHash_empty(struct JudyHash *self){
      int i;
      for (i = 0; i < HASHSIZE; i++) {
        if (self->PJLArray[i] != NULL)
	  return 0;
      }
      return 0;
    }
VALUE JudyHash_keys(struct JudyHash *self){
      VALUE ary;
      ary = rb_ary_new();
      JudyHash_foreach(self, JudyHash_keysCB, (void *) ary);
      return ary;
    }
VALUE JudyHash_values(struct JudyHash *self){
      VALUE ary;
      ary = rb_ary_new();
      JudyHash_foreach(self, JudyHash_valuesCB, (void *) ary);
      return ary;
    }
Word_t JudyHash_length(struct JudyHash const *self){
      Word_t sz = 0;
      JudyHash_foreach(self, JudyHash_lengthCB, (void *) &sz);
      return sz;
    }
VALUE JudyHash_to_a(struct JudyHash *self){
      VALUE ary;
      ary = rb_ary_new();
      JudyHash_foreach(self, JudyHash_to_aCB, (void *) ary);
      return ary;
    }
VALUE JudyHash_to_s(struct JudyHash *self){
      VALUE ary;
      ary = rb_ary_new();
      JudyHash_foreach(self, JudyHash_to_aCB, (void *) ary);
      return rb_funcall(ary, rb_intern("join"), 0);
    }
void delete_JudyHash(struct JudyHash *self){
      Word_t *PValue;
      Word_t Index, Rc_word;
      JudyHashNode *pNode, *pTmp;
      int i;
      for (i = 0; i < HASHSIZE; i++) {
        Index = 0;
        JLF(PValue, self->PJLArray[i], Index);
	while (PValue) {
	  pNode = HASHNODE(PValue);
	  while (pNode) {
	    pTmp = pNode;
	    pNode = pNode->next;
	    xfree((void *) pTmp);
	  }
	  JLN(PValue, self->PJLArray[i], Index);
	}
      	JLFA(Rc_word, self->PJLArray[i]);
      }
      xfree((void *) self);
    }

swig_class cJudyHash;
static void free_JudyHash(struct JudyHash *);
static VALUE
_wrap_Judy1_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_Judy1);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_Judy1(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (struct Judy1 *)new_Judy1();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_Judy1_set(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (bool)Judy1_set(arg1,arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Judy1_unset(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (bool)Judy1_unset(arg1,arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Judy1_test(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (bool)Judy1_test(arg1,arg2);
    
    vresult = result ? Qtrue : Qfalse;
    return vresult;
}


static VALUE
_wrap_Judy1_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    Word_t arg3 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (VALUE)Judy1_count__SWIG_0(arg1,arg2,arg3);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (VALUE)Judy1_count__SWIG_1(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE _wrap_Judy1_count(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Judy1, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_Judy1_count__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_Judy1, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_Judy1_count__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'Judy1_count'");
    return Qnil;
}


static VALUE
_wrap_Judy1_by_count(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)Judy1_by_count(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_free_array(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (Word_t)Judy1_free_array(arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Judy1_mem_used(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (Word_t)Judy1_mem_used(arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_Judy1_first_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 = (Word_t) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)Judy1_first_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_next_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)Judy1_next_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_last_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 = (Word_t) -1 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)Judy1_last_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_prev_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)Judy1_prev_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_first_empty_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 = (Word_t) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)Judy1_first_empty_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_next_empty_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)Judy1_next_empty_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_last_empty_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 = (Word_t) -1 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)Judy1_last_empty_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_prev_empty_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)Judy1_prev_empty_index(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_each_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Judy1 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (Judy1 *)Judy1_each_index(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Judy1,0);
    return vresult;
}


static VALUE
_wrap_Judy1_each_empty_index(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    Judy1 *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (Judy1 *)Judy1_each_empty_index(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_Judy1,0);
    return vresult;
}


static VALUE
_wrap_Judy1_fullq___(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (bool)Judy1_full((struct Judy1 const *)arg1);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_Judy1_to_a(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (VALUE)Judy1_to_a(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_Judy1_to_s(int argc, VALUE *argv, VALUE self) {
    struct Judy1 *arg1 = (struct Judy1 *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_Judy1, 1);
    result = (VALUE)Judy1_to_s(arg1);
    
    vresult = result;
    return vresult;
}


static void
free_Judy1(struct Judy1 *arg1) {
    delete_Judy1(arg1);
;
}
static VALUE
_wrap_JudyL_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_JudyL);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_JudyL(int argc, VALUE *argv, VALUE self) {
    struct JudyL *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (struct JudyL *)new_JudyL();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_JudyL___setitem__(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE arg3 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = argv[1];
    result = (VALUE)JudyL___setitem__(arg1,arg2,arg3);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_delete_at(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)JudyL_delete_at(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL___getitem__(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)JudyL___getitem__(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_count__SWIG_0(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    Word_t arg3 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    arg3 = NUM2ULONG(argv[1]);
    result = (VALUE)JudyL_count__SWIG_0((struct JudyL const *)arg1,arg2,arg3);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_count__SWIG_1(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (VALUE)JudyL_count__SWIG_1((struct JudyL const *)arg1);
    
    vresult = result;
    return vresult;
}


static VALUE _wrap_JudyL_count(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[4];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 3); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_JudyL, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_JudyL_count__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 3) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_JudyL, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = ((TYPE(argv[1]) == T_FIXNUM) || (TYPE(argv[1]) == T_BIGNUM)) ? 1 : 0;
            }
            if (_v) {
                {
                    _v = ((TYPE(argv[2]) == T_FIXNUM) || (TYPE(argv[2]) == T_BIGNUM)) ? 1 : 0;
                }
                if (_v) {
                    return _wrap_JudyL_count__SWIG_0(nargs, args, self);
                }
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'JudyL_count'");
    return Qnil;
}


static VALUE
_wrap_JudyL_by_count(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)JudyL_by_count((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_free_array(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (Word_t)JudyL_free_array(arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_JudyL_mem_used(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (Word_t)JudyL_mem_used((struct JudyL const *)arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_JudyL_first_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 = (Word_t) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)JudyL_first_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_next_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)JudyL_next_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_last_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 = (Word_t) -1 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)JudyL_last_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_prev_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)JudyL_prev_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_first_empty_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 = (Word_t) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)JudyL_first_empty_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_next_empty_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)JudyL_next_empty_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_last_empty_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 = (Word_t) -1 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    if (argc > 0) {
        arg2 = NUM2ULONG(argv[0]);
    }
    result = (VALUE)JudyL_last_empty_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_prev_empty_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    Word_t arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = NUM2ULONG(argv[0]);
    result = (VALUE)JudyL_prev_empty_index((struct JudyL const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_first(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (VALUE)JudyL_first((struct JudyL const *)arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_last(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (VALUE)JudyL_last((struct JudyL const *)arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_each(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    JudyL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (JudyL *)JudyL_each(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyL,0);
    return vresult;
}


static VALUE
_wrap_JudyL_each_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    JudyL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (JudyL *)JudyL_each_index(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyL,0);
    return vresult;
}


static VALUE
_wrap_JudyL_each_empty_index(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    JudyL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (JudyL *)JudyL_each_empty_index(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyL,0);
    return vresult;
}


static VALUE
_wrap_JudyL_clear(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    JudyL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (JudyL *)JudyL_clear(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyL,0);
    return vresult;
}


static VALUE
_wrap_JudyL_emptyq___(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (int)JudyL_empty((struct JudyL const *)arg1);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_JudyL_includeq___(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    VALUE arg2 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    arg2 = argv[0];
    result = (int)JudyL_include((struct JudyL const *)arg1,arg2);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_JudyL_fullq___(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    bool result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (bool)JudyL_full((struct JudyL const *)arg1);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_JudyL_to_a(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (VALUE)JudyL_to_a(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyL_to_s(int argc, VALUE *argv, VALUE self) {
    struct JudyL *arg1 = (struct JudyL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyL, 1);
    result = (VALUE)JudyL_to_s(arg1);
    
    vresult = result;
    return vresult;
}


static void
free_JudyL(struct JudyL *arg1) {
    delete_JudyL(arg1);
;
}
static VALUE
_wrap_JudySL_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_JudySL);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_JudySL(int argc, VALUE *argv, VALUE self) {
    struct JudySL *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (struct JudySL *)new_JudySL();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_JudySL___setitem__(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 ;
    VALUE arg3 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    arg2 = STR2CSTR(argv[0]);
    arg3 = argv[1];
    result = (VALUE)JudySL___setitem__(arg1,(char const *)arg2,arg3);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudySL_delete(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    arg2 = STR2CSTR(argv[0]);
    result = (VALUE)JudySL_delete(arg1,(char const *)arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudySL___getitem__(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    arg2 = STR2CSTR(argv[0]);
    result = (VALUE)JudySL___getitem__((struct JudySL const *)arg1,(char const *)arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudySL_free_array(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (Word_t)JudySL_free_array(arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_JudySL_first_key(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 = (char *) "" ;
    char *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    if (argc > 0) {
        arg2 = STR2CSTR(argv[0]);
    }
    result = (char *)JudySL_first_key((struct JudySL const *)arg1,(char const *)arg2);
    
    vresult = (result) ? rb_str_new2(result) : Qnil;
    return vresult;
}


static VALUE
_wrap_JudySL_next_key(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 ;
    char *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    arg2 = STR2CSTR(argv[0]);
    result = (char *)JudySL_next_key((struct JudySL const *)arg1,(char const *)arg2);
    
    vresult = (result) ? rb_str_new2(result) : Qnil;
    return vresult;
}


static VALUE
_wrap_JudySL_last_key__SWIG_0(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 ;
    char *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    arg2 = STR2CSTR(argv[0]);
    result = (char *)JudySL_last_key__SWIG_0((struct JudySL const *)arg1,(char const *)arg2);
    
    vresult = (result) ? rb_str_new2(result) : Qnil;
    return vresult;
}


static VALUE
_wrap_JudySL_last_key__SWIG_1(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (char *)JudySL_last_key__SWIG_1((struct JudySL const *)arg1);
    
    vresult = (result) ? rb_str_new2(result) : Qnil;
    return vresult;
}


static VALUE _wrap_JudySL_last_key(int nargs, VALUE *args, VALUE self) {
    int argc;
    VALUE argv[3];
    int ii;
    
    argc = nargs + 1;
    argv[0] = self;
    for (ii = 1; (ii < argc) && (ii < 2); ii++) {
        argv[ii] = args[ii-1];
    }
    if (argc == 1) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_JudySL, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            return _wrap_JudySL_last_key__SWIG_1(nargs, args, self);
        }
    }
    if (argc == 2) {
        int _v;
        {
            void *ptr;
            _v = (NIL_P(argv[0]) || (TYPE(argv[0]) == T_DATA && SWIG_ConvertPtr(argv[0], &ptr, SWIGTYPE_p_JudySL, 0) != -1)) ? 1 : 0;
        }
        if (_v) {
            {
                _v = (TYPE(argv[1]) == T_STRING) ? 1 : 0;
            }
            if (_v) {
                return _wrap_JudySL_last_key__SWIG_0(nargs, args, self);
            }
        }
    }
    
    rb_raise(rb_eArgError, "No matching function for overloaded 'JudySL_last_key'");
    return Qnil;
}


static VALUE
_wrap_JudySL_prev_key(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 ;
    char *result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    arg2 = STR2CSTR(argv[0]);
    result = (char *)JudySL_prev_key((struct JudySL const *)arg1,(char const *)arg2);
    
    vresult = (result) ? rb_str_new2(result) : Qnil;
    return vresult;
}


static VALUE
_wrap_JudySL_has_keyq___(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    char *arg2 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    arg2 = STR2CSTR(argv[0]);
    result = (int)JudySL_has_key(arg1,(char const *)arg2);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_JudySL_each(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    JudySL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (JudySL *)JudySL_each(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudySL,0);
    return vresult;
}


static VALUE
_wrap_JudySL_each_key(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    JudySL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (JudySL *)JudySL_each_key(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudySL,0);
    return vresult;
}


static VALUE
_wrap_JudySL_each_value(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    JudySL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (JudySL *)JudySL_each_value(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudySL,0);
    return vresult;
}


static VALUE
_wrap_JudySL_clear(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    JudySL *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (JudySL *)JudySL_clear(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudySL,0);
    return vresult;
}


static VALUE
_wrap_JudySL_emptyq___(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (int)JudySL_empty(arg1);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_JudySL_keys(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (VALUE)JudySL_keys(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudySL_values(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (VALUE)JudySL_values(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudySL_length(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (Word_t)JudySL_length((struct JudySL const *)arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_JudySL_to_a(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (VALUE)JudySL_to_a(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudySL_to_s(int argc, VALUE *argv, VALUE self) {
    struct JudySL *arg1 = (struct JudySL *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudySL, 1);
    result = (VALUE)JudySL_to_s(arg1);
    
    vresult = result;
    return vresult;
}


static void
free_JudySL(struct JudySL *arg1) {
    delete_JudySL(arg1);
;
}
static VALUE
_wrap_JudyHash_allocate(int argc, VALUE *argv, VALUE self) {
    VALUE vresult = SWIG_NewClassInstance(self, SWIGTYPE_p_JudyHash);
    rb_obj_call_init(vresult, argc, argv);
    return vresult;
}


static VALUE
_wrap_new_JudyHash(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *result;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    result = (struct JudyHash *)new_JudyHash();
    DATA_PTR(self) = result;
    return self;
}


static VALUE
_wrap_JudyHash___setitem__(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE arg2 ;
    VALUE arg3 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 2) || (argc > 2))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 2)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    arg2 = argv[0];
    arg3 = argv[1];
    result = (VALUE)JudyHash___setitem__(arg1,arg2,arg3);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyHash_delete(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    arg2 = argv[0];
    result = (VALUE)JudyHash_delete(arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyHash___getitem__(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE arg2 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    arg2 = argv[0];
    result = (VALUE)JudyHash___getitem__((struct JudyHash const *)arg1,arg2);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyHash_free_array(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (Word_t)JudyHash_free_array(arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_JudyHash_has_keyq___(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE arg2 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 1) || (argc > 1))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 1)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    arg2 = argv[0];
    result = (int)JudyHash_has_key(arg1,arg2);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_JudyHash_each(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    JudyHash *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (JudyHash *)JudyHash_each(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyHash,0);
    return vresult;
}


static VALUE
_wrap_JudyHash_each_key(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    JudyHash *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (JudyHash *)JudyHash_each_key(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyHash,0);
    return vresult;
}


static VALUE
_wrap_JudyHash_each_value(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    JudyHash *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (JudyHash *)JudyHash_each_value(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyHash,0);
    return vresult;
}


static VALUE
_wrap_JudyHash_clear(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    JudyHash *result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (JudyHash *)JudyHash_clear(arg1);
    
    vresult = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_JudyHash,0);
    return vresult;
}


static VALUE
_wrap_JudyHash_emptyq___(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    int result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (int)JudyHash_empty(arg1);
    
    vresult = (result ? Qtrue : Qfalse);
    return vresult;
}


static VALUE
_wrap_JudyHash_keys(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (VALUE)JudyHash_keys(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyHash_values(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (VALUE)JudyHash_values(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyHash_length(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    Word_t result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (Word_t)JudyHash_length((struct JudyHash const *)arg1);
    
    vresult = UINT2NUM(result);
    return vresult;
}


static VALUE
_wrap_JudyHash_to_a(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (VALUE)JudyHash_to_a(arg1);
    
    vresult = result;
    return vresult;
}


static VALUE
_wrap_JudyHash_to_s(int argc, VALUE *argv, VALUE self) {
    struct JudyHash *arg1 = (struct JudyHash *) 0 ;
    VALUE result;
    VALUE vresult = Qnil;
    
    if ((argc < 0) || (argc > 0))
    rb_raise(rb_eArgError, "wrong # of arguments(%d for 0)",argc);
    SWIG_ConvertPtr(self, (void **) &arg1, SWIGTYPE_p_JudyHash, 1);
    result = (VALUE)JudyHash_to_s(arg1);
    
    vresult = result;
    return vresult;
}


static void
free_JudyHash(struct JudyHash *arg1) {
    delete_JudyHash(arg1);
;
}

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_JudySL[] = {{"_p_JudySL", 0, "struct JudySL *", 0},{"_p_JudySL"},{0}};
static swig_type_info _swigt__p_JudyL[] = {{"_p_JudyL", 0, "struct JudyL *", 0},{"_p_JudyL"},{0}};
static swig_type_info _swigt__p_Judy1[] = {{"_p_Judy1", 0, "struct Judy1 *", 0},{"_p_Judy1"},{0}};
static swig_type_info _swigt__p_JudyHash[] = {{"_p_JudyHash", 0, "struct JudyHash *", 0},{"_p_JudyHash"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_JudySL, 
_swigt__p_JudyL, 
_swigt__p_Judy1, 
_swigt__p_JudyHash, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */


#ifdef __cplusplus
extern "C"
#endif
void Init_judy(void) {
    int i;
    
    SWIG_InitRuntime();
    mJudy = rb_define_module("Judy");
    
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
        SWIG_define_class(swig_types[i]);
    }
    
    
    assert(sizeof(Word_t) >= sizeof(VALUE));
    
    
    cJudy1.klass = rb_define_class_under(mJudy, "Judy1", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_Judy1, (void *) &cJudy1);
    rb_include_module(cJudy1.klass, rb_eval_string("Enumerable"));
    rb_define_singleton_method(cJudy1.klass, "new", _wrap_Judy1_allocate, -1);
    rb_define_method(cJudy1.klass, "initialize", _wrap_new_Judy1, -1);
    rb_define_method(cJudy1.klass, "set", _wrap_Judy1_set, -1);
    rb_define_method(cJudy1.klass, "unset", _wrap_Judy1_unset, -1);
    rb_define_method(cJudy1.klass, "test", _wrap_Judy1_test, -1);
    rb_define_method(cJudy1.klass, "count", _wrap_Judy1_count, -1);
    rb_define_method(cJudy1.klass, "by_count", _wrap_Judy1_by_count, -1);
    rb_define_method(cJudy1.klass, "free_array", _wrap_Judy1_free_array, -1);
    rb_define_method(cJudy1.klass, "mem_used", _wrap_Judy1_mem_used, -1);
    rb_define_method(cJudy1.klass, "first_index", _wrap_Judy1_first_index, -1);
    rb_define_method(cJudy1.klass, "next_index", _wrap_Judy1_next_index, -1);
    rb_define_method(cJudy1.klass, "last_index", _wrap_Judy1_last_index, -1);
    rb_define_method(cJudy1.klass, "prev_index", _wrap_Judy1_prev_index, -1);
    rb_define_method(cJudy1.klass, "first_empty_index", _wrap_Judy1_first_empty_index, -1);
    rb_define_method(cJudy1.klass, "next_empty_index", _wrap_Judy1_next_empty_index, -1);
    rb_define_method(cJudy1.klass, "last_empty_index", _wrap_Judy1_last_empty_index, -1);
    rb_define_method(cJudy1.klass, "prev_empty_index", _wrap_Judy1_prev_empty_index, -1);
    rb_define_method(cJudy1.klass, "each_index", _wrap_Judy1_each_index, -1);
    rb_define_method(cJudy1.klass, "each_empty_index", _wrap_Judy1_each_empty_index, -1);
    rb_define_method(cJudy1.klass, "full?", _wrap_Judy1_fullq___, -1);
    rb_define_method(cJudy1.klass, "to_a", _wrap_Judy1_to_a, -1);
    rb_define_method(cJudy1.klass, "to_s", _wrap_Judy1_to_s, -1);
    cJudy1.mark = 0;
    cJudy1.destroy = (void (*)(void *)) free_Judy1;
    
    cJudyL.klass = rb_define_class_under(mJudy, "JudyL", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_JudyL, (void *) &cJudyL);
    rb_include_module(cJudyL.klass, rb_eval_string("Enumerable"));
    rb_define_singleton_method(cJudyL.klass, "new", _wrap_JudyL_allocate, -1);
    rb_define_method(cJudyL.klass, "initialize", _wrap_new_JudyL, -1);
    rb_define_method(cJudyL.klass, "[]=", _wrap_JudyL___setitem__, -1);
    rb_define_method(cJudyL.klass, "delete_at", _wrap_JudyL_delete_at, -1);
    rb_define_method(cJudyL.klass, "[]", _wrap_JudyL___getitem__, -1);
    rb_define_method(cJudyL.klass, "count", _wrap_JudyL_count, -1);
    rb_define_alias(cJudyL.klass, "nitems", "count");
    rb_define_method(cJudyL.klass, "by_count", _wrap_JudyL_by_count, -1);
    rb_define_method(cJudyL.klass, "free_array", _wrap_JudyL_free_array, -1);
    rb_define_method(cJudyL.klass, "mem_used", _wrap_JudyL_mem_used, -1);
    rb_define_method(cJudyL.klass, "first_index", _wrap_JudyL_first_index, -1);
    rb_define_method(cJudyL.klass, "next_index", _wrap_JudyL_next_index, -1);
    rb_define_method(cJudyL.klass, "last_index", _wrap_JudyL_last_index, -1);
    rb_define_method(cJudyL.klass, "prev_index", _wrap_JudyL_prev_index, -1);
    rb_define_method(cJudyL.klass, "first_empty_index", _wrap_JudyL_first_empty_index, -1);
    rb_define_method(cJudyL.klass, "next_empty_index", _wrap_JudyL_next_empty_index, -1);
    rb_define_method(cJudyL.klass, "last_empty_index", _wrap_JudyL_last_empty_index, -1);
    rb_define_method(cJudyL.klass, "prev_empty_index", _wrap_JudyL_prev_empty_index, -1);
    rb_define_method(cJudyL.klass, "first", _wrap_JudyL_first, -1);
    rb_define_method(cJudyL.klass, "last", _wrap_JudyL_last, -1);
    rb_define_method(cJudyL.klass, "each", _wrap_JudyL_each, -1);
    rb_define_method(cJudyL.klass, "each_index", _wrap_JudyL_each_index, -1);
    rb_define_method(cJudyL.klass, "each_empty_index", _wrap_JudyL_each_empty_index, -1);
    rb_define_method(cJudyL.klass, "clear", _wrap_JudyL_clear, -1);
    rb_define_method(cJudyL.klass, "empty?", _wrap_JudyL_emptyq___, -1);
    rb_define_method(cJudyL.klass, "include?", _wrap_JudyL_includeq___, -1);
    rb_define_method(cJudyL.klass, "full?", _wrap_JudyL_fullq___, -1);
    rb_define_method(cJudyL.klass, "to_a", _wrap_JudyL_to_a, -1);
    rb_define_method(cJudyL.klass, "to_s", _wrap_JudyL_to_s, -1);
    cJudyL.mark = (void (*)(void *)) JudyL_markfunc;
    cJudyL.destroy = (void (*)(void *)) free_JudyL;
    
    cJudySL.klass = rb_define_class_under(mJudy, "JudySL", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_JudySL, (void *) &cJudySL);
    rb_include_module(cJudySL.klass, rb_eval_string("Enumerable"));
    rb_define_singleton_method(cJudySL.klass, "new", _wrap_JudySL_allocate, -1);
    rb_define_method(cJudySL.klass, "initialize", _wrap_new_JudySL, -1);
    rb_define_method(cJudySL.klass, "[]=", _wrap_JudySL___setitem__, -1);
    rb_define_method(cJudySL.klass, "delete", _wrap_JudySL_delete, -1);
    rb_define_method(cJudySL.klass, "[]", _wrap_JudySL___getitem__, -1);
    rb_define_method(cJudySL.klass, "free_array", _wrap_JudySL_free_array, -1);
    rb_define_method(cJudySL.klass, "first_key", _wrap_JudySL_first_key, -1);
    rb_define_method(cJudySL.klass, "next_key", _wrap_JudySL_next_key, -1);
    rb_define_method(cJudySL.klass, "last_key", _wrap_JudySL_last_key, -1);
    rb_define_method(cJudySL.klass, "prev_key", _wrap_JudySL_prev_key, -1);
    rb_define_method(cJudySL.klass, "has_key?", _wrap_JudySL_has_keyq___, -1);
    rb_define_method(cJudySL.klass, "each", _wrap_JudySL_each, -1);
    rb_define_alias(cJudySL.klass, "each_pair", "each");
    rb_define_method(cJudySL.klass, "each_key", _wrap_JudySL_each_key, -1);
    rb_define_method(cJudySL.klass, "each_value", _wrap_JudySL_each_value, -1);
    rb_define_method(cJudySL.klass, "clear", _wrap_JudySL_clear, -1);
    rb_define_method(cJudySL.klass, "empty?", _wrap_JudySL_emptyq___, -1);
    rb_define_method(cJudySL.klass, "keys", _wrap_JudySL_keys, -1);
    rb_define_method(cJudySL.klass, "values", _wrap_JudySL_values, -1);
    rb_define_method(cJudySL.klass, "length", _wrap_JudySL_length, -1);
    rb_define_alias(cJudySL.klass, "size", "length");
    rb_define_method(cJudySL.klass, "to_a", _wrap_JudySL_to_a, -1);
    rb_define_method(cJudySL.klass, "to_s", _wrap_JudySL_to_s, -1);
    cJudySL.mark = (void (*)(void *)) JudySL_markfunc;
    cJudySL.destroy = (void (*)(void *)) free_JudySL;
    
    cJudyHash.klass = rb_define_class_under(mJudy, "JudyHash", rb_cObject);
    SWIG_TypeClientData(SWIGTYPE_p_JudyHash, (void *) &cJudyHash);
    rb_include_module(cJudyHash.klass, rb_eval_string("Enumerable"));
    rb_define_singleton_method(cJudyHash.klass, "new", _wrap_JudyHash_allocate, -1);
    rb_define_method(cJudyHash.klass, "initialize", _wrap_new_JudyHash, -1);
    rb_define_method(cJudyHash.klass, "[]=", _wrap_JudyHash___setitem__, -1);
    rb_define_method(cJudyHash.klass, "delete", _wrap_JudyHash_delete, -1);
    rb_define_method(cJudyHash.klass, "[]", _wrap_JudyHash___getitem__, -1);
    rb_define_method(cJudyHash.klass, "free_array", _wrap_JudyHash_free_array, -1);
    rb_define_method(cJudyHash.klass, "has_key?", _wrap_JudyHash_has_keyq___, -1);
    rb_define_method(cJudyHash.klass, "each", _wrap_JudyHash_each, -1);
    rb_define_alias(cJudyHash.klass, "each_pair", "each");
    rb_define_method(cJudyHash.klass, "each_key", _wrap_JudyHash_each_key, -1);
    rb_define_method(cJudyHash.klass, "each_value", _wrap_JudyHash_each_value, -1);
    rb_define_method(cJudyHash.klass, "clear", _wrap_JudyHash_clear, -1);
    rb_define_method(cJudyHash.klass, "empty?", _wrap_JudyHash_emptyq___, -1);
    rb_define_method(cJudyHash.klass, "keys", _wrap_JudyHash_keys, -1);
    rb_define_method(cJudyHash.klass, "values", _wrap_JudyHash_values, -1);
    rb_define_method(cJudyHash.klass, "length", _wrap_JudyHash_length, -1);
    rb_define_alias(cJudyHash.klass, "size", "length");
    rb_define_method(cJudyHash.klass, "to_a", _wrap_JudyHash_to_a, -1);
    rb_define_method(cJudyHash.klass, "to_s", _wrap_JudyHash_to_s, -1);
    cJudyHash.mark = (void (*)(void *)) JudyHash_markfunc;
    cJudyHash.destroy = (void (*)(void *)) free_JudyHash;
}

